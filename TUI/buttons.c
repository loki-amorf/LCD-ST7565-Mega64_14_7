/** \file buttons.c
 * \brief Модуль обработки кнопок
 * содержит функции опроса состояния кнопок
 * \par
 * \author ARV
 * Copyright 2008 © ARV. All rights reserved. </b>
 * \par
 * Для сборки проекта требуется:
 * 	-# WinAVR-20080411 или более новая версия
 *
 */

#include <avr/io.h>
#include <util/delay.h>
#include "buttons.h"
#include "events.h"

/** Возврат кодов нажатых кнопок
 * @return - возвращает биты, соответствующие нажатым кнопкам или 0, если не нажато ни одной
 * \note Эта функция должна быть реализована для конкретной аппаратной платформы. Это может
 * быть сканирование матрицы, ввод состояния пинов порта и т.п. Никаких мер по подавлению дребезга
 * в этой функции быть не должно!
 */
static uint8_t get_key_code(void){
	uint8_t tmp;
	tmp = ((~PINE)>>4) & 0x0F;
	if(tmp < 4) 
		return tmp;
	else
		if(tmp == 4)
			return EV_ENTER;
		else
			return EV_ESCAPE;
}

/** Ожидает удержания кнопок заданное время
 *
 * @param key - код кнопки, удержание которой должно контролироваться
 * @param delay10ms - длительность удержания в ДЕСЯТКАХ миллисекунд
 * @return - код удержанной кнопки или 0, если кнопку отпустили до истечения задержки
 */
static uint8_t wait_key(uint8_t key, uint16_t delay20ms){
	delay20ms *= 20;
	for(; delay20ms > 0; delay20ms--){
		_delay_ms(1);
		if(key != get_key_code()) return 0;
	}
	return key;
}

/** получение кода нажатых кнопок с функциями автоповтора
 * если нажать и удерживать комбинацию кнопок,
 * то функция сначала выжидает FIRST_RPT десятков миллисекунд, а затем
 * возвращает результат через каждые RPT_DELAY десятков миллисекунд
 * @return - возвращаемое значение: биты, соответствующие нажатым кнопкам
 */
uint8_t get_key(void){
	static uint8_t oldkey = 0;
	static uint8_t first=1;
	uint8_t key, delay;

	key = wait_key(get_key_code(), 2);		// ждем 10 мс для подавления дребезга
	if(key){								// если есть нажатие
		if(!oldkey){						// если предыдущий код нулевой - это новая комбинация
			oldkey = key;					// запоминаем комбинацию и на выход
		} else {							// если предыдущая не ноль - это автоповтор
			if(first){						// первый раз перед повтором долгая выдержка
				delay = FIRST_RPT;
				first = 0;					// чтобы следующий раз отработали иначе
			} else {
				delay = RPT_DELAY;			// каждый не первый повтор с другой задержкой
			}
			key = wait_key(oldkey, delay);	// ждем удержание нужное время
		}
	}
	if(!key){								// если в конце концов вышел ноль
		first = 1;							// все начинаем заново
		oldkey = 0;
	}
	return key;								// врозвращаем результирующий код
}
